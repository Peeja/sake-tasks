# vim: syntax=Ruby

namespace :git do

  desc "Show the current status of the checkout"
  task :status do
    system "git status"
  end

  desc "Create a new topic branch"
  task :topic do
    require 'readline'
    total = `git branch`.scan("quick").size
    if total == 0
      default = "quick"
    else
      default = "quick#{total + 1}"
    end
    name = Readline.readline "Topic name (default #{default}): "
    if name.strip.empty?
      name = default
    end
    sh "git checkout -b #{name}"
  end

  desc "Push all changes to the repository"
  task :push do
    branch = `git branch | grep "*"`.strip[2..-1]
    if branch != "master"
      `git diff-files --quiet`
      if $?.exitstatus == 1
        puts "You have outstanding changes. Please commit them first."
        exit 1
      end

      puts "* Merging topic '#{branch}' back into master..."
      `git checkout master`
      sh "git merge #{branch}"
      switch = true
    else
      switch = false
    end

    puts "* Pushing changes..."
    sh "git push"

    if switch
      puts "* Switching back to #{branch}..."
      `git checkout #{branch}`
    end
  end

  desc "Pull new commits from the repository"
  task :pull do
    `git diff-files --quiet`
    if $?.exitstatus == 1
      stash = true
      clear = `git stash list`.scan("\n").size == 0
      puts "* Saving changes..."
      `git stash save`
    else
      stash = false
    end

    branch = `git branch | grep "*"`.strip[2..-1]
    if branch != "master"
      switch = true
      `git checkout master`
      puts "* Switching back to master..."
    else
      switch = false
    end

    puts "* Pulling in new commits..."
    sh "git fetch"
    sh "git rebase origin"

    if switch
      puts "* Porting changes into #{branch}..."
      `git checkout #{branch}`
      sh "git rebase master"
    end

    if stash
      puts "* Applying changes..."
      sh "git stash apply"
      `git stash clear` if clear
    end
  end

  namespace :analyze do  
    namespace :commits do
      desc 'Flog the most commonly revised files in the git history'
      task :flog_frequent do
        counts = Hash.new(0)
        IO.popen("PAGER=cat git log --name-only --pretty=oneline 2>&1") do |pipe|
          while (!pipe.eof) do
            line = pipe.readline
            next unless line =~ /^(app|lib).*\.rb$/
            counts[line.chomp] += 1
          end
        end
        counts.sort_by{|item| item.last}.reverse.first(15).each do |item|
          flog_score = `flog -s #{item.first}`.to_f.round
          puts "#{item.first} (in #{item.last} commits) (Flog: #{flog_score})"
        end
      end
    end
  end
end

namespace :ssh do
  desc "Install your public key on a remote server."
  task :install_public_key do
    begin
      require 'rubygems'
      require 'net/ssh'
      require 'net/scp'
      require 'highline'
    rescue LoadError
      abort "There was a problem loading net-ssh, net-scp, or highline.  Please make sure you have them installed via RubyGems."
    end

    public_key = if ENV["public_key_path"]
      if File.exists?(ENV["public_key_path"]) then ENV["public_key_path"] 
      else abort "The key you provided via the command line does not exist!"
      end
    else
      #discovered_key = %w[id_rsa id_dsa identity].detect { |f| File.exists?("#{ENV['HOME']}/.ssh/#{f}.pub") }
      discovered_key = %w[identity].detect { |f| File.exists?("#{ENV['HOME']}/.ssh/#{f}.pub") }
      if discovered_key then discovered_key
      else abort <<-EOS
I wasn't able to discover your public key.  I tried to find id_rsa.pub, id_dsa.pub,
or identity.pub in "#{ENV['HOME']}/.ssh".  You can hard code the path to the file by 
passing public_key_path via the command line.
        EOS
      end
    end

    h = HighLine.new
    not_blank = Proc.new { |s| !s.empty? }
    def not_blank.to_s; "not blank"; end

    h.say "I need some information to SSH into the server."
    hostname = h.ask("Remote Hostname: ") { |q| q.validate = not_blank }
    username = h.ask("Username, enter for default: ") { |q| q.default = ENV["USER"] }
    password = h.ask("Password: ") { |q| q.echo = "*" }

    begin
      Net::SSH.start(hostname, username, :password => password) do |ssh|
        puts "Uploading your public key... "
        ssh.scp.upload! public_key_path, "my_public_key"

        puts "Creating '.ssh' directory in your home directory"
        ssh.exec!("mkdir .ssh")

        puts "Concatenating your public key into the authorized_keys file"
        ssh.exec!("cat my_public_key >> .ssh/authorized_keys")

        puts "Removing your public key"
        ssh.exec!("rm my_public_key")

        puts "Setting permissions on .ssh"
        ssh.exec!("chmod 700 .ssh")

        puts "Setting permissions on your authorized_keys file"
        ssh.exec!("chmod 600 .ssh/authorized_keys")

        puts "\nAll done!  Enjoy your new, potentially password-free login."
      end
    rescue Net::SSH::AuthenticationFailed
      puts "\nWhat we've got here... is a failure to communicate.  There was a problem authenticating you."
    end
  end
end
